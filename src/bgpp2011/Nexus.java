package bgpp2011;
import java.sql.*;
import java.util.ArrayList;
import java.util.HashMap;


/*
 * This is the COMMAND CENTER / Nexus part of the database. This 
 * class initialize the connection class and uses the syntax 
 * from the COMMANDS class to communicate with the database.
 * This class is the only link to the rest of the reservation program.
 * @author Magnus Stahl
 */

public class Nexus {
	 private DataBaseCom db;
	   
	    
	    /*
	      * Initialize Nexus and a connection to the database.
	      */
	    public Nexus()
	    {
	        db = new DataBaseCom();
	    }
	    
	    /*
	     * Closes down the database. Should be used in the GUI for closing 
	     * connection and in testing.
	     */
	    
	    public void closeDatabase()
	    {
	        db.close();
	    }
	    
	    /*
	     * Creator method for reservations. Receives an incomplete (missing ID) reservation object 
	     * and inserts it in the database with an autogenerated ID. 
	     */
	    public Reservation createEntryReservation(Reservation r)
	    {
	    	ResultSet res = db.create(Commands.createReservation(r));
	    	int id = Commands.getDbID(res);
	        	if(id != -1)
	        	{
	        		return new Reservation(id,r.getCustomer(),r.getVehicle(),new Date(r.getStartdate()),new Date(r.getEnddate()));
	        	}
	        	else
	        		System.out.println("Reservation Entry Fail at ID get");
	        		return null;
	    }
	    public Customer createEntryCustomer(Customer c)
	    {
	    	int id = Commands.getDbID(db.create(Commands.createCustomer(c)));
	    	{
	    		if(id != -1)
	    		{
	    			return new Customer(id, c.getName(), c.getNumber(), c.getAddress(),c.getBankAccount());
	    		}
	    		else if(id == -1)
	    			System.out.println("Customer entry Fail at ID get");
	    			return null;
	    	}
	    }
	    public VehicleType createEntryVehicleType(VehicleType vt)
	    {
	    	int id = Commands.getDbID(db.create(Commands.createVehicleType(vt)));
	    	 if(id != -1)
	    		 	return new VehicleType(id,vt.getName(),vt.getPrice());
	    	 else
	    		 System.out.println("VehicleType entry fail at ID get");
	    	 		return null;
	    }
	    public Vehicle createEntryVehicle(Vehicle v)
	    {
	    	int id = Commands.getDbID(db.create(Commands.createVehicle(v)));
	    	if(id != -1)
	    			return new Vehicle(id,v.getMake(),v.getModel(),v.getYear(),v.getType());
	    	else
	    		System.out.println("Vehicle entry fail at ID get");
	    		return null;
	    }
	    
	  
	    public void deleteEntry()
	    {}
	    
	    public void editEntry()
	    {}
	    
	    /*
	     * The following methods returns ArrayLists containing the different types of objects 
	     * used in the Controller for modifying, searching and sorting. 
	     * These methods should be called at the loading of the program and ONLY there,
	     * as they do not guarantee consistency of data if the database itself has been changed. 
	     * Also the methods involves quite a bit of queries from the database but for now this seems
	     * like an okay method.
	     * @author msta & tbrj
	     */
	    
	    public HashMap<Integer, Vehicle> getVehicles() // Depends on the VehicleType as the objects are linked
	    {
	        ResultSet r = db.get(Commands.getVehicles());
	        HashMap<Integer, VehicleType> vtmap = getTypes();
	        return Commands.makeMapVehicles(r, vtmap);
	        
	    }
	    public HashMap<Integer, Reservation> getReservations() // Depends on Vehicles and Customer as the objects are also linked.
	    {
	        ResultSet r = db.get(Commands.getReservations());
	        HashMap<Integer, Vehicle> vmap = getVehicles();
	        HashMap<Integer, Customer> cmap = getCostumers();
	        return Commands.makeMapReservation(r, cmap, vmap);
	        		
	    }
	    public HashMap<Integer, VehicleType> getTypes() // Independent results from the database.
	    {
	       return Commands.makeMapTypes(db.get(Commands.getReservations()));
	    }
	    public HashMap<Integer, Customer> getCostumers() // Same as above.
	    {
	       return Commands.makeMapCustomer(db.get(Commands.getCustomers()));
	        
	    }
}
