package bgpp2011;
import java.sql.*;
import java.util.HashMap;


/*
 * This class is essentially the outermost part of the 'Datastoragemanagement' part of the system.
 * This class handles all connections to the database and takes in requests primarily from the 'Controlling/Model' 
 * part of the program.
 * In terms of a traditional VMC pattern, one might view this as part of the Model.
 * As of now, this class also throws all exceptions to the controller class for it to handle there.
 * In this way, this class won't be responsible for describing the errors as they should be displayed 
 * in the interface.
 * @author Magnus Stahl
 */

public class Nexus {
	 private DataBaseCom db;
	   
	    
	    /*
	      * Initialize Nexus and a connection to the database.
	      */
	    public Nexus()
	    {
	        db = new DataBaseCom();
	    }
	    
	    /*
	     * Closes down the database. Should be used in the GUI for closing 
	     * connection and in testing.
	     */
	    
	    public void closeDatabase()
	    {
	        db.close();
	    }
	    
	    /*
	     * Creator method for reservations. Receives an incomplete (missing ID) reservation object 
	     * and inserts it in the database with an autogenerated ID. 
	     * @param Reservation A valid reservation with or without id, won't matter.
	     * @return Reservation The same reservation but with a database-generated ID.
	     */
	    public Reservation createEntryReservation(Reservation r) throws SQLException
	    {
	    	int id = Commands.getDbID(db.create(Commands.createReservation(r)));
	    	return new Reservation(id,r.getCustomer(),r.getVehicle(),r.getDateStart(),r.getDateEnd());
   
	    }
	 	/*
    	 * This method sends a request to a database to create a post in a specific table using the 
    	 * Customer object from the parameter. If the query is successful, the method will return
    	 * a new Customer object with the same information as the previous but with a unique id generated
    	 * in the database.
    	 * @param Customer Any valid customer object.
    	 * @return Customer A new object alike the previous, except with a new ID.
    	 */ 
	    public Customer createEntryCustomer(Customer c) throws SQLException
	    {
	    	int id = Commands.getDbID(db.create(Commands.createCustomer(c)));
	    			return new Customer(id, c.getName(), c.getNumber(), c.getAddress(),c.getBankAccount());
	   			
	    }
	    /*
	     * This method sends a request to a database to create a post in a specific table using the 
    	 * VehicleType object from the parameter. If the query is successful, the method will return
    	 * a new VehicleType object with the same information as the previous but with a unique id generated
    	 * in the database.
    	 * @param VehicleType Any valid VehicleType object.
    	 * @return VehicleType A new object alike the previous, except with a new ID.
    	 */ 
	    public VehicleType createEntryVehicleType(VehicleType vt) throws SQLException
	    { 
	    	int id = Commands.getDbID(db.create(Commands.createVehicleType(vt)));
	    		 	return new VehicleType(id,vt.getName(),vt.getPrice());    	
	    }
		/*
    	 * This method sends a request to a database to create a post in a specific table using the 
    	 * Vehicle object from the parameter. If the query is successful, the method will return
    	 * a new Vehicle object with the same information as the previous but with a unique id generated
    	 * in the database.
    	 * @param Vehicle Any valid Vehicle object.
    	 * @return Vehicle A new object alike the previous, except with a new ID.
    	 */ 
	    public Vehicle createEntryVehicle(Vehicle v) throws SQLException
	    {
	    	int id = Commands.getDbID(db.create(Commands.createVehicle(v)));
	    			return new Vehicle(id,v.getMake(),v.getModel(),v.getYear(),v.getType());	    	
	    }
	    /*    public Data createEntry(Data entry)
	    {
	    	int id;
	    	ResultSet r; 
	    	switch(entry instanceof)
	    	{
	    	case Vehicle: 
	    	}
	    }
	    */
	    
	    /*
	     * This method requests the database connected to this class that it deletes a post in a table
	     * with information corresponding EXACTLY to the object passed in the parameter.
	     * @param Customer A customer object with information corresponding to a post in the database
	     * @return boolean true if the request was successful, false if the request failed.
	     */
	    public boolean deleteCustomer(Customer c) throws SQLException
	    {
	    	return (db.update(Commands.deleteCustomer(c)));
	    		
	    }
	    /*
	     * This method requests the database connected to this class that it deletes a post in a table
	     * with information corresponding EXACTLY to the object passed in the parameter.
	     * @param Reservation A reservation object with information corresponding to a post in the database
	     * @return boolean true if the request was successful, false if the request failed.
	     */
	    public boolean deleteReservation(Reservation r) throws SQLException
	    {
	    	return db.update(Commands.deleteReservation(r));
	    	
	    }
	    /*
	     * This method requests the database connected to this class that it deletes a post in a table
	     * with information corresponding EXACTLY to the object passed in the parameter.
	     * @param Vehicle A vehicle object with information corresponding to a post in the database
	     * @return boolean true if the request was successful, false if the request failed.
	     */
	    public boolean deleteVehicle(Vehicle v) throws SQLException
	    {
	    	return db.update(Commands.deleteVehicle(v));
	 	
	    }
	    /*
	     * This method requests the database connected to this class that it deletes a post in a table
	     * with information corresponding EXACTLY to the object passed in the parameter.
	     * @param VehicleType A VehicleType object with information corresponding to a post in the database
	     * @return boolean true if the request was successful, false if the request failed.
	     */
	    public boolean deleteVehicleType(VehicleType vt) throws SQLException
	    {
	    	return db.update(Commands.deleteVehicleType(vt));
	    	
	    }
	     
	    
	    public boolean editCustomer(Customer c) throws SQLException
	    {
	    	return db.update(Commands.updateCustomer(c));
	    
	    }
	    public boolean editReservation(Reservation r) throws SQLException
	    {
	    	return db.update(Commands.updateReservation(r));
	  
	    }
	    public boolean editVehicle(Vehicle v) throws SQLException
	    {
	    	return db.update(Commands.updateVehicle(v)); 
	    	
	    }
	    public boolean editVehicleType(VehicleType vt) throws SQLException
	    {
	    	return db.update(Commands.updateVehicleType(vt));
	  
	    }
	    
	    /*
	     * The following methods returns HashMaps containing the different types of objects 
	     * used in the Controller for modifying, searching and sorting. 
	     * These methods should be called at the loading of the program and ONLY there,
	     * as they do not guarantee consistency of data if the database itself has been changed. 
	     * Also the methods involves quite a bit of queries from the database but for now this seems
	     * like an okay method.
	     * @author msta & tbrj
	     */
	    
	    public HashMap<Integer, Vehicle> getVehicles() throws SQLException 
	    // Depends on the VehicleType as the objects are linked
	    {
	        HashMap<Integer, VehicleType> vtmap = getTypes();
	        ResultSet r = db.get(Commands.getVehicles());
	        return Commands.makeMapVehicles(r, vtmap);
	        
	    }
	    public HashMap<Integer, Reservation> getReservations() throws SQLException
	    // Depends on Vehicles and Customer as the objects are also linked.
	    {
	        
	        HashMap<Integer, Vehicle> vmap = getVehicles();
	        HashMap<Integer, Customer> cmap = getCostumers();
	        ResultSet r = db.get(Commands.getReservations());
	        return Commands.makeMapReservation(r, cmap, vmap);
	        		
	    }
	    public HashMap<Integer, VehicleType> getTypes() throws SQLException	
	    // Independent results from the database.
	    {
	       return Commands.makeMapTypes(db.get(Commands.getTypes()));
	    }
	    public HashMap<Integer, Customer> getCostumers() throws SQLException
	    // Same as above.
	    {
	       return Commands.makeMapCustomer(db.get(Commands.getCustomers()));
	        
	    }
}
